/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface Position {
  /** 1-based line number in the source file. */
  line: number
  /** 1-based column number in the source file. */
  column: number
}
export interface RangeWithoutByte {
  start: Position
  end: Position
}
export interface RangePair {
  before: RangeWithoutByte
  after: RangeWithoutByte
}
export interface FileDiff {
  oldPath?: string
  newPath?: string
  ranges: Array<RangePair>
}
export interface RichFile {
  path: string
  content: string
}
export enum SearchOutputOptions {
  /** Emit absolute paths */
  AbsolutePaths = 'AbsolutePaths',
  /** Emit paths relative to the provided search/root directory */
  RelativePaths = 'RelativePaths'
}
export interface SearchOptions {
  targetPaths: Array<string>
  stepId: string
  /** Skip emitting any results and applying changes */
  silent?: boolean
  /** The format of the output paths */
  outputFormat?: SearchOutputOptions
  /** Verify the query without applying any changes */
  verifyOnly?: boolean
}
export interface InputFile {
  path: string
  content: string
}
export interface InputOptions {
  files: Array<InputFile>
}
export class JsResolvedBinding {
  /**
   * Retrieves the stringified representation of the binding.
   *
   * This method accesses the binding's text representation, using the current state's files
   * and the specified language context.
   */
  text(): string
  /** Returns the range of the binding. */
  range(): RangeWithoutByte | null
  /** Retrieve a variable's text value. */
  var(name: string): string | null
  /** Retrieves the absolute file name of the file containing the current binding. */
  filename(): string
  /** Inserts the provided text after the binding. */
  insertAfter(text: string): void
}
export class QueryBuilder {
  /** Construct a new query, starting from a GritQL query */
  constructor(baseQuerySrc: string)
  /**
   * Add a callback to filter the results of the search
   *
   * @param filter A callback that that will be called with each match, it should return true to keep the match
   */
  filter(filter: MatchCallback): void
  /**
   * Set a replacement rewrite to the query
   *
   * @param replacement The replacement rewrite to apply to the query
   */
  setReplacement(replacement: string): void
  /**
   * Add an insertion to the query
   *
   * @param insertion The insertion to add to the query
   */
  addInsertion(insertion: string): void
  /**
   * Pipe the query into another query
   * When you pipe a query, it will stop directly emitting results itself.
   * Instead, every *matching* file will be passed to the next query.
   * @param query The query to pipe into
   */
  pipe(secondQuery: QueryBuilder): void
  /**
   * Run the query on the provided files
   * @param target_paths A list of paths to search for matches
   * @returns A list of files that matched the query
   */
  run(options: SearchOptions): Promise<Array<string>>
  /**
   * Apply the query to a single file and return the modified file (if any)
   * @param file The file to apply the query to
   * @returns The modified file (if any)
   */
  applyToFile(file: InputFile): Promise<InputFile | null>
}
